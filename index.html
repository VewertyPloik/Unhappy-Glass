<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Fill the Glass â€” Sad Cup (Mobile Ready)</title>
<style>
  :root{
    --bg:#8ec8f2;
    --panel:#a7daf7;
    --accent:#004466;
    --btn:#0b84d6;
    --danger:#cc3333;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(#9fd6ff,#dff6ff);-webkit-tap-highlight-color:transparent}
  .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;gap:8px;padding:10px}
  h1{margin:6px 0;color:var(--accent);font-size:20px}
  #gameWrap{
    width:min(420px,96vw);
    aspect-ratio: 2/3; /* comfortable tall area for mobile */
    background:var(--panel);
    border:3px solid var(--accent);
    border-radius:12px;
    position:relative;
    overflow:hidden;
    touch-action:none;
  }
  canvas{position:absolute;left:0;top:0;width:100%;height:100%;display:block}
  #ui{width:100%;display:flex;gap:8px;flex-wrap:wrap;justify-content:space-between;align-items:center;margin-top:6px}
  button{
    background:var(--btn);color:#fff;border:0;padding:10px 12px;border-radius:8px;font-weight:700;
    box-shadow:0 2px 0 rgba(0,0,0,0.15);flex:1;min-width:86px;
  }
  button:disabled{background:#9bbfd8;opacity:.9}
  #levelText{flex:1;text-align:center;color:var(--accent);font-weight:800}
  #message{width:min(420px,96vw);text-align:center;color:var(--accent);min-height:22px;margin-top:6px;font-weight:700}
  /* small helper for top-right "tap to steer" hint */
  .hint{position:absolute;right:8px;top:8px;background:rgba(255,255,255,0.8);padding:6px;border-radius:8px;font-size:12px;color:#034}
</style>
</head>
<body>
<div class="wrap">
  <h1>Fill the Glass â€” Sad Cup</h1>
  <div id="gameWrap">
    <div class="hint">Touch to steer â€¢ Draw line to guide</div>
    <canvas id="drawLayer"></canvas>     <!-- lines & tap visuals & obstacles -->
    <canvas id="waterLayer"></canvas>    <!-- particles -->
    <canvas id="glassLayer"></canvas>    <!-- glass + water fill + face + target line -->
  </div>

  <div id="ui">
    <button id="releaseBtn">Release Water</button>
    <button id="resetBtn">Reset Line</button>
    <div id="levelText">Level 1 / 10</div>
    <button id="nextBtn" disabled>Next Level</button>
  </div>

  <div id="message"></div>
</div>

<script>
(() => {
  // ----- Setup & HiDPI scaling -----
  const gameWrap = document.getElementById('gameWrap');
  const cDraw = document.getElementById('drawLayer');
  const cWater = document.getElementById('waterLayer');
  const cGlass = document.getElementById('glassLayer');
  const ctxDraw = cDraw.getContext('2d');
  const ctxWater = cWater.getContext('2d');
  const ctxGlass = cGlass.getContext('2d');

  function resizeCanvases(){
    const rect = gameWrap.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    [cDraw, cWater, cGlass].forEach(c=>{
      c.width = Math.round(rect.width * dpr);
      c.height = Math.round(rect.height * dpr);
      c.style.width = rect.width + 'px';
      c.style.height = rect.height + 'px';
      const ctx = c.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      // smoothing
      ctx.imageSmoothingEnabled = true;
    });
    // update internal sizes
    WIDTH = rect.width;
    HEIGHT = rect.height;
    computeLayout();
    drawStatic();
  }
  window.addEventListener('resize', resizeCanvases);
  // initial call after DOM ready
  let WIDTH = 360, HEIGHT = 540; // defaults until resized
  resizeCanvases();

  // ----- Game state -----
  let currentLevel = 1;
  const MAX_LEVEL = 10;
  const messageEl = document.getElementById('message');
  const releaseBtn = document.getElementById('releaseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const nextBtn = document.getElementById('nextBtn');
  const levelText = document.getElementById('levelText');

  // local progress
  function saveProgress(){ localStorage.setItem('sadFillLevel', currentLevel); }
  function loadProgress(){
    const v = parseInt(localStorage.getItem('sadFillLevel'));
    if(Number.isInteger(v) && v>=1 && v<=MAX_LEVEL) currentLevel = v;
  }
  loadProgress();

  // drawing line points (guides)
  let drawing = false;
  let guidePoints = [];

  // water control
  let waterReleased = false;
  let waterParticles = [];
  let spawnAcc = 0;
  const WATER_RATE = 1.8; // particles per frame approx
  let pointerActive = false;
  let pointerPos = {x: null, y: null}; // when finger down -> steering target

  // tap pivot and default aim (we won't require rotating handle now)
  let spout = {x: null, y: null}; // computed in computeLayout

  // glass layout
  let glass = {x: null, y: null, w: null, h: null};
  let waterLevel = 0; // 0..1

  // obstacles per level (line segments)
  const levels = [
    {target:0.30, glassH: 0.45, obstacles: []},
    {target:0.36, glassH: 0.46, obstacles: [{x1:0.55,y1:0.66,x2:0.78,y2:0.66}]},
    {target:0.44, glassH: 0.48, obstacles: [{x1:0.45,y1:0.64,x2:0.70,y2:0.58}]},
    {target:0.50, glassH: 0.50, obstacles: [{x1:0.52,y1:0.66,x2:0.70,y2:0.60},{x1:0.78,y1:0.62,x2:0.92,y2:0.60}]},
    {target:0.56, glassH: 0.51, obstacles: [{x1:0.50,y1:0.70,x2:0.75,y2:0.70},{x1:0.64,y1:0.56,x2:0.88,y2:0.46}]},
    {target:0.62, glassH: 0.53, obstacles: [{x1:0.48,y1:0.72,x2:0.74,y2:0.66},{x1:0.76,y1:0.62,x2:0.92,y2:0.56},{x1:0.40,y1:0.58,x2:0.52,y2:0.46}]},
    {target:0.68, glassH: 0.54, obstacles: [{x1:0.46,y1:0.74,x2:0.78,y2:0.74},{x1:0.62,y1:0.58,x2:0.82,y2:0.50}]},
    {target:0.74, glassH: 0.56, obstacles: [{x1:0.50,y1:0.76,x2:0.84,y2:0.76},{x1:0.70,y1:0.60,x2:0.90,y2:0.52}]},
    {target:0.80, glassH: 0.57, obstacles: [{x1:0.48,y1:0.78,x2:0.86,y2:0.78},{x1:0.72,y1:0.64,x2:0.92,y2:0.56},{x1:0.36,y1:0.60,x2:0.54,y2:0.52}]},
    {target:0.86, glassH: 0.59, obstacles: [{x1:0.50,y1:0.80,x2:0.88,y2:0.80},{x1:0.74,y1:0.68,x2:0.92,y2:0.64},{x1:0.40,y1:0.64,x2:0.58,y2:0.56}]}
  ];

  // compute pixel positions for obstacles based on canvas size
  let computedObstacles = [];

  // level mechanics
  let levelComplete = false;

  // helper: convert normalized percent coords (0..1) to pixels
  function pxX(norm){ return Math.round(norm * WIDTH); }
  function pxY(norm){ return Math.round(norm * HEIGHT); }

  // compute layout positions (glass, spout, obs)
  function computeLayout(){
    // spout near top-left quarter
    spout.x = Math.round(WIDTH * 0.12);
    spout.y = Math.round(HEIGHT * 0.12);
    // glass centered bottom
    const glassWidth = Math.round(WIDTH * 0.44);
    const glassHnorm = levels[currentLevel-1].glassH; // portion of canvas height
    glass.w = glassWidth;
    glass.h = Math.round(HEIGHT * glassHnorm);
    glass.x = Math.round((WIDTH - glass.w)/2);
    glass.y = Math.round(HEIGHT - (glass.h + Math.round(HEIGHT*0.08))); // leave small base margin

    // obstacles: translate normalized to px
    computedObstacles = levels[currentLevel-1].obstacles.map(o => ({
      x1: pxX(o.x1), y1: pxY(o.y1),
      x2: pxX(o.x2), y2: pxY(o.y2)
    }));
  }

  // ----- Drawing static pieces (glass, target line, obstacles, guide) -----
  function clearAll(){
    ctxDraw.clearRect(0,0,WIDTH,HEIGHT);
    ctxWater.clearRect(0,0,WIDTH,HEIGHT);
    ctxGlass.clearRect(0,0,WIDTH,HEIGHT);
  }

  function drawGlassAndTarget(){
    ctxGlass.clearRect(0,0,WIDTH,HEIGHT);

    // glass body (rounded bottom) background
    ctxGlass.save();
    ctxGlass.lineWidth = 3;
    ctxGlass.strokeStyle = '#003B56';
    ctxGlass.fillStyle = '#dff4ff';
    // body path
    const gx = glass.x, gy = glass.y, gw = glass.w, gh = glass.h;
    ctxGlass.beginPath();
    ctxGlass.moveTo(gx, gy);
    ctxGlass.lineTo(gx, gy + gh - 24);
    // bottom arc
    ctxGlass.quadraticCurveTo(gx + gw/2, gy + gh + 12, gx + gw, gy + gh - 24);
    ctxGlass.lineTo(gx + gw, gy);
    ctxGlass.closePath();
    ctxGlass.fill();
    ctxGlass.stroke();
    ctxGlass.restore();

    // water fill (drawn after we compute waterLevel)
    const levelData = levels[currentLevel-1];
    const waterPx = Math.round(levelDataTargetFillToPixels(waterLevel));
    // water rectangle within glass boundaries (simple top-flat fill)
    ctxGlass.save();
    ctxGlass.beginPath();
    ctxGlass.fillStyle = '#2f9fff';
    const left = gx + 4, right = gx + gw - 4;
    const bottom = gy + gh - 24 + 4; // inner bottom
    const top = bottom - waterPx;
    ctxGlass.rect(left, top, right-left, waterPx);
    ctxGlass.fill();
    ctxGlass.restore();

    // draw dashed target line
    const targetPx = Math.round(levelDataTargetFillToPixels(levelData.target));
    ctxGlass.save();
    ctxGlass.strokeStyle = '#cc3333';
    ctxGlass.lineWidth = 3;
    ctxGlass.setLineDash([10,6]);
    ctxGlass.beginPath();
    ctxGlass.moveTo(gx + 6, bottom - targetPx);
    ctxGlass.lineTo(gx + gw - 6, bottom - targetPx);
    ctxGlass.stroke();
    ctxGlass.setLineDash([]);
    ctxGlass.restore();

    // draw sad face on cup center (two eyes, frown)
    ctxGlass.save();
    const faceCx = gx + gw/2;
    const faceCy = gy + Math.round(gh * 0.36);
    // eyes
    ctxGlass.fillStyle = '#003B56';
    ctxGlass.beginPath(); ctxGlass.arc(faceCx - 18, faceCy - 6, 4, 0, Math.PI*2); ctxGlass.fill();
    ctxGlass.beginPath(); ctxGlass.arc(faceCx + 18, faceCy - 6, 4, 0, Math.PI*2); ctxGlass.fill();
    // frown
    ctxGlass.lineWidth = 3;
    ctxGlass.strokeStyle = '#003B56';
    ctxGlass.beginPath();
    ctxGlass.arc(faceCx, faceCy + 8, 18, Math.PI*0.2, Math.PI*0.8, true); // upside-down arc
    ctxGlass.stroke();
    ctxGlass.restore();
  }

  // helper: convert level target (0..1) into pixel height of glass fill
  function levelDataTargetFillToPixels(ratio){
    // ratio relative to current glass.h
    return ratio * (glass.h - 28); // subtract some inner padding
  }

  // draw obstacles and guide line and spout visuals on draw layer
  function drawDrawLayer(){
    ctxDraw.clearRect(0,0,WIDTH,HEIGHT);
    // draw spout
    ctxDraw.save();
    ctxDraw.fillStyle = '#666';
    ctxDraw.strokeStyle = '#333';
    ctxDraw.lineWidth = 2;
    ctxDraw.beginPath();
    ctxDraw.rect(spout.x - 2, spout.y - 2, 42, 18);
    ctxDraw.fill();
    ctxDraw.stroke();
    // small circle to show spawn point
    ctxDraw.fillStyle = '#b33';
    ctxDraw.beginPath();
    ctxDraw.arc(spout.x + 40, spout.y + 7, 8, 0, Math.PI*2);
    ctxDraw.fill();
    ctxDraw.restore();

    // obstacles
    ctxDraw.save();
    ctxDraw.strokeStyle = '#6b3f00';
    ctxDraw.lineWidth = 10;
    ctxDraw.lineCap = 'round';
    for(const o of computedObstacles){
      ctxDraw.beginPath();
      ctxDraw.moveTo(o.x1, o.y1);
      ctxDraw.lineTo(o.x2, o.y2);
      ctxDraw.stroke();
    }
    ctxDraw.restore();

    // guide line (drawn by player)
    if(guidePoints.length>0){
      ctxDraw.save();
      ctxDraw.lineWidth = 6;
      ctxDraw.strokeStyle = '#7a3fcf';
      ctxDraw.lineCap = 'round';
      ctxDraw.lineJoin = 'round';
      ctxDraw.beginPath();
      ctxDraw.moveTo(guidePoints[0].x, guidePoints[0].y);
      for(let i=1;i<guidePoints.length;i++) ctxDraw.lineTo(guidePoints[i].x, guidePoints[i].y);
      ctxDraw.stroke();
      ctxDraw.restore();
    }

    // If pointerActive show a steering dot where you're touching
    if(pointerActive && pointerPos.x !== null){
      ctxDraw.save();
      ctxDraw.fillStyle = 'rgba(255,255,255,0.9)';
      ctxDraw.beginPath();
      ctxDraw.arc(pointerPos.x, pointerPos.y, 16, 0, Math.PI*2);
      ctxDraw.fill();
      ctxDraw.strokeStyle = '#004466';
      ctxDraw.lineWidth = 2;
      ctxDraw.stroke();
      ctxDraw.restore();
    }
  }

  // ----- Water particle behavior -----
  class Particle {
    constructor(x,y,vx,vy){
      this.x = x; this.y = y;
      this.vx = vx; this.vy = vy;
      this.r = 3.0;
      this.alive = true;
    }
    update(){
      // gravity
      this.vy += 0.18;
      // apply simple drag
      this.vx *= 0.999;
      this.vy *= 0.999;

      // move
      this.x += this.vx;
      this.y += this.vy;

      // collision with guide line segments
      for(let i=0;i<guidePoints.length-1;i++){
        const p1 = guidePoints[i], p2 = guidePoints[i+1];
        const d = distToSegment({x:this.x,y:this.y}, p1, p2);
        if(d < this.r + 4){
          // simple bounce/reflection: approximate normal
          const nx = p2.y - p1.y;
          const ny = -(p2.x - p1.x);
          const len = Math.hypot(nx, ny) || 1;
          const unx = nx/len, uny = ny/len;
          const dot = this.vx*unx + this.vy*uny;
          this.vx = this.vx - 2*dot*unx;
          this.vy = this.vy - 2*dot*uny;
          // small push so it doesn't stick
          this.x += this.vx*0.5; this.y += this.vy*0.5;
        }
      }

      // obstacles collision (thick obstacle lines)
      for(const o of computedObstacles){
        const d = distToSegment({x:this.x,y:this.y}, {x:o.x1,y:o.y1}, {x:o.x2,y:o.y2});
        if(d < this.r + 6){
          const dx = o.x2 - o.x1, dy = o.y2 - o.y1;
          const len = Math.hypot(dx,dy) || 1;
          const nx = -dy / len, ny = dx / len; // normal
          const dot = this.vx*nx + this.vy*ny;
          this.vx = this.vx - 2*dot*nx;
          this.vy = this.vy - 2*dot*ny;
          this.x += this.vx*0.4; this.y += this.vy*0.4;
        }
      }

      // inside glass clamp and settle
      if(pointInGlass(this.x, this.y)){
        // reduce velocity and settle toward current water top
        this.vx *= 0.3; this.vy *= 0.3;
        // make the particle sit on top of current waterLevel top
        const levelPixel = Math.round(levelDataTargetFillToPixels(waterLevel));
        const bottom = glass.y + glass.h - 24 + 4;
        const top = bottom - levelPixel;
        if(this.y > top - 1){
          this.y = top - 1;
          this.vx = 0; this.vy = 0;
        }
      }

      // remove if out of bounds
      if(this.y > HEIGHT + 30 || this.x < -50 || this.x > WIDTH + 50) this.alive = false;
    }
    draw(ctx){
      ctx.beginPath();
      ctx.fillStyle = '#2f9fff';
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function distToSegment(p, p1, p2){
    const l2 = (p2.x - p1.x)**2 + (p2.y - p1.y)**2;
    if(l2 === 0) return Math.hypot(p.x - p1.x, p.y - p1.y);
    let t = ((p.x - p1.x)*(p2.x - p1.x) + (p.y - p1.y)*(p2.y - p1.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    const projx = p1.x + t*(p2.x - p1.x);
    const projy = p1.y + t*(p2.y - p1.y);
    return Math.hypot(p.x - projx, p.y - projy);
  }

  // Check if a point (px,py) is considered inside the glass interior (approx)
  function pointInGlass(px,py){
    const gx = glass.x, gy = glass.y, gw = glass.w, gh = glass.h;
    if(px < gx+2 || px > gx + gw -2) return false;
    if(py < gy + 2) return false;
    if(py > gy + gh - 2) return false;
    // approximate bottom curve allowance
    const bottomY = gy + gh - 24;
    if(py > bottomY){
      const centerX = gx + gw/2;
      const radius = 36;
      const dist = Math.hypot(px - centerX, py - bottomY);
      return dist < radius;
    }
    return true;
  }

  // ----- Spawn logic: water aims toward cup center by default, or toward finger while touching -----
  function computeSpawnVector(){
    // spawn point at end of spout rectangle
    const spawnX = spout.x + 40;
    const spawnY = spout.y + 7;
    // target:
    let tx, ty;
    if(pointerActive && pointerPos.x !== null){
      tx = pointerPos.x; ty = pointerPos.y;
    } else {
      // aim at glass top center
      tx = glass.x + glass.w/2;
      ty = glass.y + Math.round(glass.h*0.45);
    }
    const dx = tx - spawnX; const dy = ty - spawnY;
    const dist = Math.hypot(dx,dy) || 1;
    // base speed depends on how far; clamp speed
    const speed = Math.min(4.0, 1.5 + dist / 100);
    return {spawnX, spawnY, vx: dx/dist * speed, vy: dy/dist * speed};
  }

  // ----- Game loop -----
  function update(){
    if(!levelComplete && waterReleased){
      spawnAcc += WATER_RATE;
      while(spawnAcc >= 1){
        const sv = computeSpawnVector();
        waterParticles.push(new Particle(sv.spawnX, sv.spawnY, sv.vx * (0.9 + Math.random()*0.2), sv.vy * (0.9 + Math.random()*0.2)));
        spawnAcc--;
      }
    }

    // update particles
    for(const p of waterParticles) p.update();
    // remove dead
    for(let i = waterParticles.length -1; i>=0; i--) if(!waterParticles[i].alive) waterParticles.splice(i,1);

    // compute waterLevel approximated by counting particles inside glass region
    const levelData = levels[currentLevel-1];
    const topY = glass.y + 6;
    const bottomY = glass.y + glass.h - 24 + 4;
    let countInside = 0;
    for(const p of waterParticles){
      if(p.x > glass.x + 6 && p.x < glass.x + glass.w - 6 && p.y > topY && p.y < bottomY) countInside++;
    }
    const maxParticles = 160; // tune: more particles means fuller glass
    waterLevel = Math.min(1, countInside / maxParticles);

    // check completion (must be between tolerance around target) and waterReleased true
    if(waterReleased){
      const target = levelData.target;
      // allow small window: must be >= target - tolLow and <= target + tolHigh to be success
      const tolLow = 0.02, tolHigh = 0.05;
      if(waterLevel >= target - tolLow && waterLevel <= target + tolHigh){
        levelComplete = true;
        messageEl.textContent = 'Level Complete! Tap Next Level.';
        nextBtn.disabled = false;
        releaseBtn.disabled = true;
        resetBtn.disabled = true;
      } else if(waterLevel > target + tolHigh){
        // overflow -> stop flow and require reset
        waterReleased = false;
        messageEl.textContent = 'Too much water â€” reset and try again.';
        releaseBtn.disabled = true;
        resetBtn.disabled = false;
      } else {
        messageEl.textContent = ''; // keep quiet while filling
      }
    }

    // draw everything
    drawLayers();

    requestAnimationFrame(update);
  }

  function drawLayers(){
    // draw glass layer (glass body + water fill + target + sad face)
    drawGlassAndTarget();

    // water layer (particles)
    ctxWater.clearRect(0,0,WIDTH,HEIGHT);
    for(const p of waterParticles) p.draw(ctxWater);

    // draw layer (spout, guide line, obstacles, pointer)
    drawDrawLayer();
  }

  // ----- Input handling (pointer events) -----
  // We use pointer events so it works for mouse and touch and stylus
  const drawLayerEl = cDraw;
  drawLayerEl.addEventListener('pointerdown', (e) => {
    // if the user touches near the spout area but not drawing, treat as steer pointer
    const rect = drawLayerEl.getBoundingClientRect();
    const x = (e.clientX - rect.left);
    const y = (e.clientY - rect.top);
    // start drawing if touch is not long on spout region; user can draw anywhere
    drawing = true;
    guidePoints = [];
    addGuidePoint(x,y);
    e.preventDefault();
  }, {passive:false});

  drawLayerEl.addEventListener('pointermove', (e) => {
    const rect = drawLayerEl.getBoundingClientRect();
    const x = (e.clientX - rect.left);
    const y = (e.clientY - rect.top);
    if(drawing && !waterReleased){
      addGuidePoint(x,y);
    }
    // also treat pointer move as steering when pointer is pressed (pointerdown) or on touchmove while water flows
    if(e.pressure !== 0 || e.buttons !== 0 || e.pointerType === 'touch'){
      pointerActive = true;
      pointerPos.x = x; pointerPos.y = y;
    }
    e.preventDefault();
  }, {passive:false});

  window.addEventListener('pointerup', (e) => {
    drawing = false;
    // pointer may still be active for steering if touch stays; pointerup clears steering
    pointerActive = false;
    pointerPos.x = null; pointerPos.y = null;
  });

  function addGuidePoint(x,y){
    // clamp inside canvas
    x = Math.max(0, Math.min(WIDTH, x));
    y = Math.max(0, Math.min(HEIGHT, y));
    // avoid adding jitter points
    if(guidePoints.length === 0) guidePoints.push({x,y});
    else {
      const last = guidePoints[guidePoints.length-1];
      if(Math.hypot(last.x-x, last.y-y) > 6) guidePoints.push({x,y});
    }
    drawDrawLayer();
  }

  // UI buttons
  releaseBtn.addEventListener('click', () => {
    if(waterReleased || levelComplete) return;
    if(guidePoints.length < 2){
      messageEl.textContent = 'Draw a guiding line first!';
      return;
    }
    messageEl.textContent = 'Water released â€” move your finger to steer.';
    waterReleased = true;
    releaseBtn.disabled = true;
    resetBtn.disabled = true;
  });

  resetBtn.addEventListener('click', () => {
    if(waterReleased) return;
    guidePoints = [];
    waterParticles = [];
    waterLevel = 0;
    spawnAcc = 0;
    messageEl.textContent = '';
    drawLayers();
  });

  nextBtn.addEventListener('click', () => {
    if(currentLevel < MAX_LEVEL){
      currentLevel++;
      saveProgress();
      startLevel();
    } else {
      messageEl.textContent = 'You finished all levels! ðŸŽ‰';
      nextBtn.disabled = true; releaseBtn.disabled = true; resetBtn.disabled = true;
    }
  });

  // start or restart a level
  function startLevel(){
    // reset flags & arrays
    waterParticles = [];
    guidePoints = [];
    waterLevel = 0;
    spawnAcc = 0;
    waterReleased = false;
    pointerActive = false;
    pointerPos = {x:null,y:null};
    levelComplete = false;
    messageEl.textContent = '';
    nextBtn.disabled = true;
    releaseBtn.disabled = false;
    resetBtn.disabled = false;
    levelText.textContent = `Level ${currentLevel} / ${MAX_LEVEL}`;
    computeLayout();
    drawLayers();
  }

  // init & start
  computeLayout();
  resizeCanvases(); // ensure correct sizes & draws
  startLevel();
  requestAnimationFrame(update);

  // redraw when orientation/size changes (debounced)
  let resizeTimer = null;
  window.addEventListener('resize', ()=>{
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(()=>{ resizeCanvases(); startLevel(); }, 80);
  });

  // initial draw helper
  function drawStatic(){
    computeLayout();
    drawLayers();
  }

  // expose drawLayers for initial draws
  drawStatic();

  // ensure UI show correct level text initially
  levelText.textContent = `Level ${currentLevel} / ${MAX_LEVEL}`;

  // small accessibility: allow keyboard Next & Reset for desktop testers
  window.addEventListener('keydown', (e)=>{
    if(e.key === 'n') nextBtn.click();
    if(e.key === 'r') resetBtn.click();
  });

})();
</script>
</body>
</html>
